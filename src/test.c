#include <locale.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <wchar.h>

#include "lib.c"

int n_passed = 0;
int n_failed = 0;

char **test_names;
int n_tests;

// UTILS

int assert_fails = 0;

void assert_array(char *name, int size, double *expected, double *actual)
{
    int equals = 1;
    for (int i = 0; i < size; i++)
    {
        if (fabs(expected[i] - actual[i]) > 0.000001)
        {
            equals = 0;
            break;
        }
    }

    if (!equals)
    {
        assert_fails += 1;
        printf("array comparison %s\"%s\"%s failed\n", BOLD, name, RESET);
        printf("expected: ");
        print_array(size, expected);
        printf("  actual: ");
        print_array(size, actual);
        printf("\n");
    }
}

void assert_scalar(char *name, double expected, double actual)
{
    if (fabs(expected - actual) > 0.001)
    {
        assert_fails += 1;
        printf("scalar comparison %s\"%s\"%s failed\n", BOLD, name, RESET);
        printf("expected: %f\n", expected);
        printf("  actual: %f\n\n", actual);
    }
}

// TESTS

/* automatically generated by 'generate_test.py' */
#include "test_backprop.c"

void test_serialization()
{
    // todo: open this in memory
    FILE *file = fopen("test.model", "wb+");

    int ndim = 5;
    int dims[] = {2, 3, 4, 3, 2};
    Network network = network_create(ndim, dims);

    // serialize
    serialize_network(network, file);
    int expected_size = 4 + 4 * network.ndim;
    for (int l = 1; l < network.ndim; l++)
    {
        expected_size += 8 * network.dims[l] * (1 + network.dims[l - 1]);
    }

    assert_scalar("expected file size", expected_size, ftell(file));

    fseek(file, 0, SEEK_SET);

    Network deserialized = deserialize_network(file);
    for (int l = 1; l < ndim; l++)
    {
        assert_array("compare deserialized weights", dims[l] * dims[l - 1], deserialized.weights[l], network.weights[l]);
        assert_array("compare deserialized biases", dims[l], deserialized.biases[l], network.biases[l]);
    }

    fclose(file);
}

// CLI

void run_test(char *name, void test())
{
    int is_selected = n_tests == 0;
    for (int i = 0; i < n_tests; i++)
    {
        is_selected = is_selected || !strcmp(name, test_names[i]);
    }

    if (!is_selected)
        return;

    printf("%sRunning \"%s\"%s\n", BOLD, name, RESET);
    assert_fails = 0;
    test();
    if (assert_fails == 0)
    {
        n_passed += 1;
        printf("\U00002705 %spassed%s\n", GREEN, RESET);
    }
    else
    {
        n_failed += 1;
        printf("\U0000274c %sfailed%s\n", RED, RESET);
    }
    printf("\n");
}

double timestamp()
{
    struct timespec start;
    clock_gettime(CLOCK_REALTIME, &start);
    return start.tv_sec + start.tv_nsec / 1000000000;
}

// USAGE

void print_usage()
{
    printf("Usage:\n\n");
    printf("    %sneural test [<names>]%s\n\n", BOLD, RESET);
    printf("Run specified tests, otherwise run all.\n\n");
}

int main(int argc, char *argv[])
{
    if (argc > 1 && strcmp(argv[1], "--help") == 0)
    {
        print_usage();
        return 0;
    }

    srand(0);

    test_names = argv + 1;
    n_tests = argc - 1;

    double start = timestamp();

    run_test("test_back_propagation", test_back_propagation);
    run_test("test_serialization", test_serialization);

    double end = timestamp();

    printf("Ran %s%d%s tests (%s%d%s passed / %s%d%s failed) in %.2f s\n",
           BOLD, n_passed + n_failed, RESET,
           GREEN, n_passed, RESET,
           RED, n_failed, RESET,
           end - start);

    return n_failed != 0;
}
